____
# Practice

### 2. 1 Примитивные типы

_Укажите пары эквивалентных булевских операторов.
Операторы эквивалентны, если их таблицы истинности совпадают, т.е. для любой пары аргументов оба оператора дают один и тот же результат.
Если ответ не очевиден, то составьте таблицы истинности для всех упомянутых операторов и сравните их._

 - | и ||
 - ~~| и !=~~
 - ~~& и ==~~
 - ^ и !=

_Реализуйте метод, возвращающий true, если среди четырех его аргументов ровно два истинны (любые). Во всех остальных случаях метод должен возвращать false.
Воспользуйтесь шаблоном кода, который предлагает система. Ввод-вывод будет сделан за вас. Вам надо только проанализировать переданные в метод booleanExpression значения (a, b, c, d) и вернуть результат. Попробуйте составить формулу с использованием булевых операторов. Если не получается, вернитесь к этому заданию после просмотра степов про условные операторы и циклы.
При записи сложных выражений рекомендуется использовать скобки, чтобы не запутаться в порядке применения операторов.
В качестве примера уже указано заведомо некорректное решение задачи. Исправьте его.
Совет тем, у кого не проходит какой-то из тестов. В данной задаче возможно всего 16 комбинаций значений входных параметров. Их можно выписать на бумажку, посчитать для них правильные ответы и сравнить с тем, что выдает ваше решение. Попробуйте самостоятельно проделать это, найти ошибку и исправить решение._

```java
    public static boolean booleanExpression(boolean a, boolean b, boolean c, boolean d) {
        return ((a ^ b) && (c ^ d)) || ((a ^ c) && (b ^ d)) || ((a ^ d) && (b ^ c));
    }
```

_В Григорианском календаре год является високосным в двух случаях: либо он кратен 4, но при этом не кратен 100, либо кратен 400.
Реализуйте метод, вычисляющий количество високосных лет с начала нашей эры (первого года) до заданного года включительно. На самом деле Григорианский календарь был введен значительно позже, но здесь для упрощения мы распространяем его действие на всю нашу эру.
Ввод-вывод обеспечивает проверяющая система. Вам надо только проанализировать переданное в метод значение и вернуть результат. В программу всегда подается положительный номер года. Предполагается решение без циклов. Вам надо придумать и записать несложную формулу, использующую только арифметические операторы.
В качестве примера написано заведомо неправильное выражение. Исправьте его._

```Java
    public static int leapYearCount(int year) {
        return (year - (year % 4)) / 4 - ((year - (year % 100)) / 100 - (year - (year % 400)) / 400);
    }
```

_Реализуйте метод, возвращающий ответ на вопрос: правда ли, что a + b = c?
Допустимая погрешность – 0.0001 (1E-4)
Можно использовать класс Math и его методы. Класс Math доступен всегда, импортировать его не надо.
В качестве примера написано заведомо неправильное выражение. Исправьте его._

```Java
    public static boolean doubleExpression(double a, double b, double c) {
        if (java.lang.Math.abs((a + b) - c) < 1E-4 )
                return true;
           else
               return false;
    }
```

_Какой тип имеет литерал 0x0bp3?
Введите имя соответствующего примитивного типа. Напоминаем, что Java чувствительна к регистру символов._

 - double

_Укажите размер целочисленного типа int в Java._

 - ~~Известно только, что sizeof(short) <= sizeof(int) <= sizeof(long). Конкретный размер зависит от платформы.~~
 - ~~Размер динамически изменяется, чтобы вместить любое нужное пользователю целое число.~~
 - ~~16 бит~~
 - 32 бита

_Реализуйте метод flipBit, изменяющий значение одного бита заданного целого числа на противоположное. Данная задача актуальна, например, при работе с битовыми полями.
Договоримся, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32).
Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система._

```Java
    public static int flipBit(int value, int bitIndex) {
        return value ^ (1 << (bitIndex - 1));
        }
        public static void main(String[] args) {
            System.out.println(flipBit(6, 2));
    }
```
____
### 2. 2 Преобразование типов

_Реализуйте метод, который возвращает букву, стоящую в таблице UNICODE после символа "\" (обратный слэш) на расстоянии a.
В качестве примера написано заведомо неправильное выражение. Исправьте его._

```Java
    public static char charExpression(int a) {
        int s = '\\';
        int total = s + a;
        char unicode = (char) total;
        return unicode;
    }
```

_Зачем в Java, объектно-ориентированном языке, есть примитивные типы, не являющиеся объектами? Ведь есть полноценные объекты-аналоги java.lang.Integer и т.п._

 - Примитивные типы нужны для производительности вычислений. Работа с объектами намного медленнее. (+)
 - Примитивные типы — пережиток ранних версий Java. Теперь их не могут убрать из-за обратной совместимости.
 - Примитивные типы — это просто синонимы для соответсвующих ссылочных типов. Т.е. int — синоним для java.lang.Integer и т.п.
 - Чтобы всех запутать.
 
_Укажите преобразования типов, которые компилятор делает автоматически. Другими словами, для каких преобразований не требуется явно писать в программе оператор приведения типа?_
 
 - ~~int -> boolean~~
 - ~~String -> int~~
 - ~~byte -> char~~
 - char -> Character
 - long -> float 
 - int -> long 
 - ~~float -> long~~
 - char -> int
 
_Реализуйте метод, проверяющий, является ли заданное число по абсолютной величине степенью двойки.
Решать можно разными способами:
 - воспользовавшись одним удобным статическим методом из класса java.lang.Integer;
 - применив пару трюков из двоичной арифметики;
 - написав решение "в лоб" с циклом и условными операторами (можете вернуться к этой задаче после просмотра соответствующих уроков).
Воспользуйтесь предоставленны

```Java
    public static boolean isPowerOfTwo(int value) {
        if (value == 0) {
                return false;
            }
            else {
                int result = Math.abs(value);
                return (result & (result - 1)) == 0;
            }
    }
```
____
### 2. 3 Массивы и строки

_Выберите выражения, которые дадут в качестве результата строку A12._

 - 'A' + "12"
 - "A" + ('\t' + '\u0003')
 - "A" + 12
 - ~~'A' + '1' + "2"~~
 
_Можно ли создать массив нулевой длины?_

 - ~~Нет~~
 - Да
 
_Реализуйте метод, проверяющий, является ли заданная строка палиндромом. Палиндромом называется строка, которая читается одинаково слева направо и справа налево (в том числе пустая). При определении "палиндромности" строки должны учитываться только буквы и цифры. А пробелы, знаки препинания, а также регистр символов должны игнорироваться. Гарантируется, что в метод попадают только строки, состоящие из символов ASCII (цифры, латинские буквы, знаки препинания). Т.е. русских, китайских и прочих экзотических символов в строке не будет.
Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система.
Подсказки (не читайте, если хотите решить сами):
 - для удаления из строки всех символов, не являющихся буквами и цифрами, можно воспользоваться регулярным выражением "[^a-zA-Z0-9]"; найдите в классе String метод, выполняющий замену по регулярному выражению;
 - для перестановки символов строки в обратном порядке можно воспользоваться методом reverse(), который находится в классе StringBuilder;
 - в классе String есть методы для преобразования всей строки в верхний и нижний регистр._
 
 ```Java
       public static boolean isPalindrome(String text) {
           String replaced = text.toLowerCase().replaceAll("[^A-Za-z0-9]", "");
               String reversed = new StringBuffer(replaced).reverse().toString();
               return reversed.equals(replaced);
           }
           public static void Main(String[] args) {
               System.out.println(isPalindrome("Madam, I'm Adam!"));
       }
```
____
### 2. 4 Управляющие конструкции: условные операторы и циклы

_Значения каких типов могут использоваться в операторе switch?_

 - String
 - ~~float~~
 - int
 - ~~long~~
 - ~~boolean~~
 - char
 
_Эквивалентны ли два следующих цикла?_
 
 ```Java
    for (int i = 0; i < 100; i++) {
        // тело цикла
    }
    
    for (int i = 0; i < 100; ) {
        // тело цикла
        i++;
    }
```
    
 - ~~Не эквивалентны, когда в теле цикла есть другой вложенный цикл~~
 - ~~Всегда эквивалентны~~
 - Не эквивалентны, когда в теле цикла используется continue
 - ~~Не эквивалентны, когда в теле цикла используется break~~
 
_Реализуйте метод, вычисляющий факториал заданного натурального числа.
Факториал N вычисляется как 1⋅2⋅...⋅N.
Поскольку это очень быстро растущая функция, то даже для небольших N вместимости типов int и long очень скоро не хватит. Поэтому будем использовать BigInteger.
Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система._

```Java
    public static BigInteger factorial(int value) {
        BigInteger result = BigInteger.ONE;
        for (int i = 1; i <= value; i++)
            result = result.multiply(BigInteger.valueOf(i));
        return result; 
    }
```
    
_Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один отсортированный в том же порядке массив. Массивы могут быть любой длины, в том числе нулевой.
Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность: он будет идти по двум исходным массивам и сразу формировать отсортированный результирующий массив. Так, чтобы сортировка полученного массива при помощи Arrays.sort() уже не требовалась. К сожалению, автоматически это не проверить, так что это остается на вашей совести :)
Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система._

```Java
    public static int[] mergeArrays(int[] a1, int[] a2) {
        if (a1 == null)
            return a2;
        if (a2 == null)
            return a1;
        int[] range = new int[a1.length + a2.length];
        int j1 = 0;
        int j2 = 0;
        for (int i = 0; i < range.length; i++){
            if ((j1 < a1.length) && (j2 < a2.length)){
                if (a1[j1] < a2[j2]){
                    range[i] = a1[j1];
                    j1++;
                } 
                else {
                    range[i] = a2[j2];
                    j2++;                        
                }
                } 
            else if (j1 < a1.length) {
                range[i] = a1[j1];
                j1++;
            }
            else if (j2 < a2.length) {
                range[i] = a2[j2];
                j2++; 
            }
        }
        return range;
    }
```
____
